[![Board Status](https://dev.azure.com/wwwgamesensepub/85926823-5bbc-4a97-87aa-78e79db23598/1043a6c1-41d4-435f-8291-997110805037/_apis/work/boardbadge/f2ef5ef6-ce58-4b4a-bfbf-b8a7373f3069)](https://dev.azure.com/wwwgamesensepub/85926823-5bbc-4a97-87aa-78e79db23598/_boards/board/t/1043a6c1-41d4-435f-8291-997110805037/Microsoft.RequirementCategory) > **_NOTE:_** this site is live @`https://h4xr0x.cc
 # @`https://discord.gg/EYCBURUPcm 

## GAMESENSE.IS | GAMESENSE.PUB | SKEET.CC 
```
// original gamesense.pub crack (fake) gamesense.pub staff leaked the lua workshop, the gamesensical staff group dox'd the documentation which lead to it being // used in other cheat sources as api.gamesense.is = gcode solutions, legendware, nixware, dota2 company login. in directory you can find the build't in cheat // sources; the " crack" is leak of DLC ( downloadable content ) skeet is legendary because of the users who made that content. The cheat is an original paste, // the base buildt in cheat is by valve, extended by the community of modders, of which the hvh community gives crown to the rage content made by skeet users. // Which content can be used in this "crack" .
```
# gs Project 

### Application

*   GroupId: `gamesense.org.acme`
*   ArtifactId: `gs`
*   Version: `1.0.0-SNAPSHOT`
*   Quarkus Version: `2.3.0.Final`


#  This project uses Quarkus, the Supersonic Subatomic Java Framework.

#  Gamesense.pub cracked Loader, cheat engine & scripting CLI

####  For help or more tutorials, leaks, cheats, hacks & h4xr0x join the community or follow here:
#### */* https://gamesense.cloud
#### */* https://h4xr0x.cc
#### */* https://discord.gg/EYCBURUPcm

# Tutorial: How to build gamesense.pub's loader
![image](https://user-images.githubusercontent.com/65768277/188307392-2f8fc600-b244-45d2-b1b6-b70d80b2c1a6.png)

# Prerequisites 

*   you will need to install WSL2: https://ubuntu.com/tutorials/working-with-visual-studio-code-on-ubuntu-on-wsl2#1-overview 

*   you will need Ubuntu 20.04:  https://apps.microsoft.com/store/detail/ubuntu-20044-lts/9MTTCL66CPXJ

*   you will need to install NodeJS: https://ubuntu.com/tutorials/working-with-visual-studio-code-on-ubuntu-on-wsl2#5-install-nodejs-and-create-a-new-project

*   you will need to install sdkman: 

```
curl -s "https://get.sdkman.io" | bash
```

*   you will need to then install ``sdk install maven`` ``sdk instal spring-boot`` ``sudo apt-get install openjdk-11-jdk`` ``sdk list java`` ``sdk install quarkus``

*   you will need to install: Visual Studio Code https://code.visualstudio.com/

*   you will need to install the Remote Development extention: https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-   extensionpack

*   you will need to install docker desktop: https://docs.docker.com/desktop/install/windows-install/

# Running the application in dev mode

You can run your application in dev mode that enables live coding using:
```shell script
./mvnw compile quarkus:dev
```

> **_NOTE:_**  Quarkus now ships with a Dev UI, which is available in dev mode only at http://localhost:8080/q/dev/.

## Packaging and running the application

The application can be packaged using:

```shell script
./mvnw package
```
It produces the `quarkus-run.jar` file in the `target/quarkus-app/` directory.
Be aware that it’s not an _über-jar_ as the dependencies are copied into the `target/quarkus-app/lib/` directory.

The application is now runnable using `java -jar target/quarkus-app/quarkus-run.jar`.

If you want to build an _über-jar_, execute the following command:
```shell script
./mvnw package -Dquarkus.package.type=uber-jar
```

The application, packaged as an _über-jar_, is now runnable using `java -jar target/*-runner.jar`.

## Creating a native executable

You can create a native executable using: 
```shell script
./mvnw package -Pnative
```

Or, if you don't have GraalVM installed, you can run the native executable build in a container using: 
```shell script
./mvnw package -Pnative -Dquarkus.native.container-build=true
```

You can then execute your native executable with: `./target/gs-1.0.0-SNAPSHOT-runner`

If you want to learn more about building native executables, please consult https://quarkus.io/guides/maven-tooling.html.

## Related Guides
![image](https://user-images.githubusercontent.com/65768277/188334606-487d29fb-d3e9-4994-87bc-1e2ae29236ef.png)
- YAML Configuration ([guide](https://quarkus.io/guides/config#yaml)): Use YAML to configure your Quarkus application
- Quarkus Extension for Spring Web API ([guide](https://quarkus.io/guides/spring-web)): Use Spring Web annotations to create your REST services

## Provided Code

### YAML Config

Configure your application with YAML

[Related guide section...](https://quarkus.io/guides/config-reference#configuration-examples)

The Quarkus application configuration is located in `src/main/resources/application.yml`.

### Spring Web

Spring, the Quarkus way! Start your RESTful Web Services with a Spring Controller.

[Related guide section...](https://quarkus.io/guides/spring-web#greetingcontroller)
*   Your static assets are located in `src/main/resources/META-INF/resources`.
*   Configure your application in `src/main/resources/application.yml`.
*   Quarkus now ships with a [Dev UI](/q/dev/) (available in dev mode only)
*   Play with the provided code located in `src/main/java`:

### Spring Web

Spring, the Quarkus way! Start your RESTful Web Services with a Spring Controller.

`@Path: [/greeting](/greeting)`

[Related guide section...](https://quarkus.io/guides/spring-web#greetingcontroller)

The Quarkus application configuration is located in `src/main/resources/application.yml`.

### Spring Web

Spring, the Quarkus way! Start your RESTful Web Services with a Spring Controller.

[Related guide section...](https://quarkus.io/guides/spring-web#greetingcontroller)
*   Your static assets are located in `src/main/resources/META-INF/resources`.
*   Configure your application in `src/main/resources/application.yml`.
*   Quarkus now ships with a [Dev UI](/q/dev/) (available in dev mode only)
*   Play with the provided code located in `src/main/java`:

### Spring Web

Spring, the Quarkus way! Start your RESTful Web Services with a Spring Controller.

`@Path: [/greeting](/greeting)`

[Related guide section...](https://quarkus.io/guides/spring-web#greetingcontroller)

ABOUT GAMESENSICAL GameSense

*   Steam Group Administrators: NmChris and Wish
*   Steam Group Moderators: Beta Users Only
*   https://steamcommunity.com/groups/gamesensical
![image](https://user-images.githubusercontent.com/65768277/188335613-a12b7615-3df2-4b6e-99ab-c8555f58d4f5.png)
*  https://gamesensical.gitbook.io/docs/
   
`@original: dev branch: https://github.com/h4xrOx/gamesense_docs | https://github.com/jessy-lua/docs/pull/1

![image](https://user-images.githubusercontent.com/65768277/188262381-7db4dc2d-2b31-4211-9f86-6df11a66cf5f.png) 

![image](https://user-images.githubusercontent.com/65768277/188335387-0fc72594-5372-49d9-ac32-91a31506a0a6.png)

# Building the GameSense.pub Loader

## Assuming you have:

*   Set up your enviorment
*   updated and applied configurations
*   you will need to install sdkman `$ curl -s "https://get.sdkman.io" | bash`
*   you will need to then install `sdk install maven` `sdk instal spring-boot` `sudo apt-get install openjdk-11-jdk` `sdk list java` `sdk install quarkus`
*   you will need to install: Visual Studio Code https://code.visualstudio.com/
*   you will need to install the Remote Development extention: https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack
*   you will need to install docker desktop: https://docs.docker.com/desktop/install/windows-install/

## Install NodeJS

```
sudo apt update
sudo apt upgrade
```

```
sudo apt-get install nodejs

sudo apt install npm
```

### Now, create a new folder for our server.

```
mkdir server/
```

### Then navigate into it:

```
cd server/
```

#### */* -- Now, open up your folder in Visual Studio Code, you can do this by typing: `code`. The first time you do this, it will trigger a download for the necessary dependencies:

# Installing OpenSSH Server on Ubuntu 20.04 

* install the remote ssh extention: vscode:extension/ms-vscode-remote.remote-ssh

* follow the instructions here to set up SSH: https://code.visualstudio.com/docs/remote/ssh-tutorial

* Aways, make sure that your current packages are up to date for security purposes.

```
sudo apt-get update
```

```
sudo apt-get upgrade
```

### Now that all packages are up-to-date, run the “apt-get install” command in order to install OpenSSH.

```
sudo apt-get install openssh-server
```

# Create an SSH key

### If you don't have an SSH key pair, a bash shell or the command line and type in:

```
ssh-keygen -t ed25519
```

### ctrl+3 or on toolbar `veiw` select `command palete` and select " public key" from the drop down box:
![image](https://user-images.githubusercontent.com/65768277/188313106-d98c1013-f301-43d7-b616-26a4a9792293.png)

### From steps displayed on your console, you should see A configuration file is created in the `/etc/ssh` a folder named `sshd_config`. Symbolic links are created. One named `sshd.service` (your systemd service) and one in the multi-user target (to boot SSH when you log in).

```
sudo systemctl status sshd
```

```
netstat -tulpn | grep 22^
```

### if you don't have netstat by default

 ```
 sudo apt-get install net-tools
 ```

-------------------------------------------------------------------------------------------------------------------------------------------------------------

# Enabling SSH traffic on your firewall settings

### To enable SSH connections on your host, run the following command

```
sudo ufw allow ssh
```

### To check if you are using UFW firewall

```
sudo ufw status
```

### If not enabled, run the following command

```
sudo ufw enable
``` 

```
sudo ufw reset
```

## Enable SSH server on system boot

```
sudo systemctl list-unit-files | grep enabled | grep ssh
```

### If you have no results on your terminal, you should “enable” the service in order for it to be launched at boot time.

```
sudo systemctl enable ssh
```

### Restarting your SSH server to apply the changes

```
sudo systemctl restart sshd
```

```
sudo systemctl status sshd
```

### Enabling port 8080 for the API, enter the following command:

```
netstat -tulpn | grep
```

### If you are doing this on LAN to use locally make sure to get the local IP by

```
sudo ifconfig
```

### In order to connect to your SSH server, you will use your username and ip address

```
ssh -p <port> <username>@<ip_address>
```

### DISABLING your SSH server, for any reason you type the following commands

```
sudo systemctl stop sshd
```

```
sudo systemctl status sshd
```

-------------------------------------------------------------------------------------------------------------------------------------------------------------

# Fork this repo and load the project in Visual Studio Code to create the Hello World Quarkus app, During this part of the tutorial we will be completing the following tasks:

*   Bootstrapping an application

*   Creating a JAX-RS endpoint

*   Injecting beans

*   Functional tests

*   Packaging of the application

## Prerequisites To complete this guide, you need:

*  Roughly 15 minutes
*  Visual Studio Code or another IDE
*  JDK 11+ installed with JAVA_HOME configured appropriately
*  Apache Maven 3.8.1+
*  Optionally the Quarkus CLI if you want to use it & it: https://quarkus.io/guides/cli-tooling

#### open an integrated terminal in WSL Ubuntu from the `/demo/gs/` directory. Type the following command and make sure to follow any instructions that may pop up due to dependancies to install sdkman:

```
curl -s "https://get.sdkman.io" | bash
```

#### open a new terminal in the same directory and type the following commands to finish the installation of sdkman:

```
source "$HOME/.sdkman/bin/sdkman-init.sh"
```
 ``sdk install maven`` ``sdk instal spring-boot`` ``sdk isntall java`` ``sdk install quarkus``
*/* 

#### As root user type the following command:

```
mvn io.quarkus.platform:quarkus-maven-plugin:2.12.0.Final:create \
    -DprojectGroupId=gamesense.org.acme \
    -DprojectArtifactId=gs
```
 
 #### */* -- If you have all dependancies, followed the instructions and your screen mirrors the image below, congradulations!! You are on you way to owning gamesense.pub!

![image](https://user-images.githubusercontent.com/65768277/188302306-47028f3e-209c-483a-a5dd-08963db39880.png)

# the Maven structure 

*  an org.gamesense.acme.GreetingResource resource exposed on /hello

*  an associated unit test

*  a landing page that is accessible on http://localhost:8080 after starting the application

*   example Dockerfile files for both native and jvm modes in `src/main/docker`

*   the application configuration file

Once generated, look at the pom.xml. You will find the import of the Quarkus BOM, allowing you to omit the version of the different Quarkus dependencies. In addition, you can see the quarkus-maven-plugin responsible of the packaging of the application and also providing the development mode. I had you navigate to `/demo/gs/` so you could this. I have already buildt the application in the main directory which has all dependancies and structure as a to guide you at any point you feel you need a reference.

# The JAX-RS resources

### During the project creation, the src/main/java/org/acme/GreetingResource.java file has been created with the following content:
```
package org.gamesense.acme;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "Hello from RESTEasy Reactive";
    }
}
```
-------------------------------------------------------------------------------------------------------------------------------------------------------------

# It’s a very simple REST endpoint, returning "Hello from RESTEasy Reactive" to requests on "/hello".

## Now we are ready to run our application, type the following command:

```
./mvnw quarkus:dev
```

## Your IDE should give you a simular output as the image below:

![image](https://user-images.githubusercontent.com/65768277/188303464-8c4ef7dc-8f4b-4cbd-aaa4-7d73d6600d4f.png)

## Once started, you can request the provided endpoint:

```
$ curl -w "\n" http://localhost:8080/hello

Hello from RESTEasy Reactive
```

> **_NOTE:_** We are using `curl -w "\n"` in this example to avoid your terminal printing a `'%'` or put both result and next command prompt on the same line. Hit `CTRL+C` to stop the application, or keep it running and enjoy the blazing fast hot-reload. Automatically add newline with `curl -w "\n"`

 ----------------------------------------------------------------------------------------------------------------------------------------------------------------

# Using injection

*   Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection

*   ArC comes as a dependency of quarkus-resteasy-reactive so you already have it handy. 

*   if you stopped the application, restart it with the following command:

```
./mvnw quarkus:dev
```

### Then check that the endpoint returns hello quarkus as expected:

```
$ curl -w "\n" http://localhost:8080/hello/greeting/quarkus

hello quarkus
```

#### Normally you have to Modify the application and add a companion bean. Create the src/main/java/org/acme/GreetingService.java, navigate to it, here is where we can add import dependancies and features we want to add for testing or updates.

# Development Mode

####
All that Gamesense.pub and cheat documentation. How does it work? How did I hack it? I'll tell you. RESTful API's use whats known as The OAS contract describes what the API does, it’s request parameters and response objects, all without any indication of code implementation. Web services defined with OAS can communicate with each other irrespective of the language they’re built in, since OAS is language agnostic and machine readable. 

# OAS Generation During Runtime

### Swagger-core is the Java implementation of Swagger. Current version supports JAX-RS and plain servlets.

####
 In this method, the Swagger/OAS contract is generated from an API based on the meta-data added against the various resources, methods and controllers. This meta-data will generate the contract, client-side code, and other artifacts during runtime. Typically, this meta-data will be in the form of code annotations. The tools trigger as the various methods and functions are called against their resources, and produces the OAS contract from the metadata defined in the API.

# There are three steps required to generate an OAS document from an existing API:

*  Adding dependencies to your application
*  Hooking Swagger Core to the Application
*  Initialize the OAS Contract

####
The Swagger project uses maven for build and deployment of artifacts, available on Maven Central. Maven dependencies need JAX-RS coded API for Swagger Core to run. We hooked Swagger Core into the API with spring to get the dependancies. OAS definition can be initialized within an application during its runtime. The generated OAS definition will be in two files, defined in JSON and YAML. Take a look at swagger inspector https://swagger.io/tools/swagger- and insert the end point of the resource you want to have documented. You can then navigate to the right panel from the History section of Swagger Inspector, and click "Create API definition" to create the OAS definition.

![image](https://user-images.githubusercontent.com/65768277/188306662-47be1365-ad39-459a-be89-c85a815cb8a6.png)



# Package and run the application

```
./mvnw quarkus:dev
```

## Open your browser to http://localhost:8080/greeting.

## The result should be: `{"message": "hello"}.`

> **_NOTE:_** quarkus:dev runs Quarkus in development mode. This enables live reload with background compilation, which means that when you modify your Java files and/or your resource files and refresh your browser, these changes will automatically take effect. This works too for resource files like the configuration property file. Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know. This will also listen for a debugger on port 5005. If you want to wait for the debugger to attach before running you can pass `-Dsuspend` on the command line. If you don’t want the debugger at all you can use `-Ddebug=false`.

## Run the application as a native executable

# Prerequisites

*   JDK 11+ installed with JAVA_HOME configured appropriately

*   Apache Maven 3.8.1+

*   A working container runtime (Docker or Podman) Related guide: https://quarkus.io/guides/podman
   
   
 ```sudo apt install podman podman-docker docker-compose
   ```
   
#### Enable the podman socket with Docker REST API (only needs to be done once)

```
systemctl --user enable podman.socket --now
```
#### Set the required environment variables (need to be run everytime or added to profile)

```
export DOCKER_HOST=unix:///run/user/${UID}/podman/podman.sock
```
 
 > **_NOTE:_**  A working C development environment you'll need to download Visual Studio 2017 Visual C++ Build Tools: https://aka.ms/vs/15/release/vs_buildtools.exe 
  
```
cmd /c 'call "C:\Program Files (x86)\Microsoft Visual Studio\2017\BuildTools\VC\Auxiliary\Build\vcvars64.bat" && mvn package -Pnative'
```
## Mandrel or GraalVM recommended for building native executables that target Linux containerized environments. Install JDK & GraalVM using sdkman; if you havent got it already `sdk java list` will show all versions available.

 #### Configure the runtime environment. Set GRAALVM_HOME environment variable to the GraalVM installation directory
 
 ```
 export GRAALVM_HOME=$HOME/demo/gs/
 ```

  #### */* -- https://github.com/graalvm/mandrel/releases
  
  #### */* -- https://github.com/graalvm/mandrel/blob/default/README.md
  
## Java preview features
 
> **_NOTE:_** Java code that relies on preview features requires special attention. To produce a native executable, this means that the --enable-preview flag needs to be passed to the underlying native image invocation. You can do so by prepending the flag with -J and passing it as additional native build argument: -Dquarkus.native.additional-build-args=-J—​enable-preview.

## On Linux, you will need GCC, and the glibc and zlib headers. Examples for common distributions

```
sudo apt-get install build-essential libz-dev zlib1g-dev
```

```
apt install g++ zlib1g-dev libfreetype6-dev
```

# Quick Start

```
$ tar -xf mandrel-java17-linux-amd64-22.2.0.0-Final.tar.gz
$ export JAVA_HOME="$( pwd )/mandrel-java17-22.2.0.0-Final"
$ export GRAALVM_HOME="${JAVA_HOME}"
$ export PATH="${JAVA_HOME}/bin:${PATH}"
$ curl -O -J https://code.quarkus.io/d?e=io.quarkus:quarkus-resteasy-reactive
$ unzip code-with-quarkus.zip
$ cd code-with-quarkus/
$ ./mvnw package -Pnative
$ ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner
```

## Using the builder image on Windows with Docker Desktop (mind Resources-> File sharing settings so as Quarkus project directory is mountable).

```
powershell -c "Invoke-WebRequest -OutFile quarkus.zip -Uri https://code.quarkus.io/d?e=io.quarkus:quarkus-resteasy-reactive"
powershell -c "Expand-Archive -Path quarkus.zip -DestinationPath . -Force
cd code-with-quarkus
mvnw package -Pnative -Dquarkus.native.container-build=true -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:22.2.0.0-Final-java17
docker build -f src/main/docker/Dockerfile.native -t my-quarkus-mandrel-app .
docker run -i --rm -p 8080:8080 my-quarkus-mandrel-app
```

> **_NOTE:_** It is also possible to use Podman for Windows with appending: -Dquarkus.native.container-runtime=podman..

-------------------------------------------------------------------------------------------------------------------------------------------------------------

# Building the native executable

## Java preview features

#### */* -- 
Java code that relies on preview features requires special attention. To produce a native executable, this means that the --enable-preview flag needs to be passed to the underlying native image invocation. You can do so by prepending the flag with -J and passing it as additional native build argument: -Dquarkus.native.additional-build-args=-J—​enable-preview. 
#### */* -- 

# One of the easiest ways to create container-image from a Quarkus application is to leverage one of the container-image extensions. 

### Add OpenAPI and Swagger-UI extention :

```
./mvnw quarkus:add-extension -Dextensions="io.quarkus:quarkus-smallrye-openapi"
```

```
mvnw package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true
```

```
./mvnw package -Dnative
```
 
 ![image](https://user-images.githubusercontent.com/65768277/188314749-32b38b39-81c4-4e34-8fff-ee0220da1883.png)


### The command below is enough to generate a basic OpenAPI schema document from your REST Endpoints You will see the generated OpenAPI schema document launched in your browser with swagger ui:

```
curl http://localhost:8080/q/openapi
```

  #### */* -- if successful in your connection; the server is running and you can now open launcher.exe and use the Gamesense cheat.
  
  #### */* -- If unsuccessful join https://gamesense.cloud and get a FREE API key with the registration of your account. The project's home is there.
  ![image](https://user-images.githubusercontent.com/65768277/188336742-b784eaa8-2648-48c8-8bee-a8dc9a01a008.png)

  cRackCrAcKcrrAcKK h4xr0x#1337
  
  #### If you would like to view the origonal source as I got it from Gamesense: https://github.com/h4xrOx/gamesense.cloud/tree/main/demo/gs


